--  docker run --name signin-postgres -p5432:5432 -e POSTGRES_USER=signin -e POSTGRES_PASSWORD=foobar -d postgres

DROP TYPE IF EXISTS COMPETITION;
CREATE TYPE COMPETITION as ENUM('FRC', 'FTC', 'FLL');

DROP TYPE IF EXISTS PARENTRELATION;
CREATE TYPE PARENTRELATION as ENUM('Father', 'Mother', 'Guardian');

DROP TABLE IF EXISTS people;
CREATE TABLE people (
  PersonID INT GENERATED BY DEFAULT AS IDENTITY (START WITH 100) PRIMARY KEY, --INTEGER PRIMARY KEY,
  CheckInID TEXT UNIQUE NOT NULL,
  FirstName TEXT NOT NULL,
  LastName  TEXT NOT NULL,
  Email     TEXT,
  Phone     TEXT,

  SchoolEmail TEXT,
  SchoolID    TEXT
);

DROP TABLE IF EXISTS meetings;
CREATE TABLE meetings(
  MeetingID INT GENERATED BY DEFAULT AS IDENTITY (START WITH 100) PRIMARY KEY, --INTEGER PRIMARY KEY,

  Date      DATE NOT NULL,
  StartTime TIME NOT NULL,
  EndTime   TIME NOT NULL,
  Location  TEXT NOT NULL, -- TOOD make location its own table?
  Kind      TEXT NOT NULL
);

DROP TABLE IF EXISTS teams;
CREATE TABLE teams (
  TeamID INT GENERATED BY DEFAULT AS IDENTITY (START WITH 100) PRIMARY KEY,

  Compeition  COMPETITION NOT NULL, -- FIX typo
  Number      INTEGER NOT NULL,
  Name        TEXT NOT NULL,

  UNIQUE (Compeition, Number)
);

DROP TABLE IF EXISTS team_meetings;
CREATE TABLE team_meetings (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  TeamID    INTEGER REFERENCES teams (TeamID)       ON DELETE SET NULL,
  MeetingID INTEGER REFERENCES meetings (MeetingID) ON DELETE SET NULL,

  UNIQUE (TeamID, MeetingID)
);

CREATE OR REPLACE FUNCTION fn_team_meetings_nulldel()
  RETURNS TRIGGER AS
$func$
  BEGIN
    DELETE FROM team_meetings WHERE id = NEW.id;
    RETURN NULL;
  END;
$func$ LANGUAGE plpgsql;

CREATE TRIGGER trg_team_meetings_nulldel
  BEFORE UPDATE OF TeamID, MeetingID on team_meetings
  FOR EACH ROW
  WHEN  (NEW.TeamID IS NULL OR NEW.MeetingID IS NULL)
  EXECUTE PROCEDURE fn_team_meetings_nulldel();

DROP TABLE IF EXISTS commitments;
CREATE TABLE commitments (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  PersonID  INTEGER REFERENCES people(PersonID)    ON DELETE SET NULL,
  MeetingID INTEGER REFERENCES meetings(MeetingID) ON DELETE SET NULL,

  UNIQUE(PersonID, MeetingID)
);

CREATE OR REPLACE FUNCTION fn_commitments_nulldel()
  RETURNS TRIGGER AS
$func$
  BEGIN
    DELETE FROM commitments WHERE id = NEW.id;
    RETURN NULL;
  END;
$func$ LANGUAGE plpgsql;

CREATE TRIGGER trg_commitments_nulldel
  BEFORE UPDATE OF PersonID, MeetingID on commitments
  FOR EACH ROW
  WHEN  (NEW.PersonID IS NULL OR NEW.MeetingID IS NULL)
  EXECUTE PROCEDURE fn_commitments_nulldel();


DROP TABLE IF EXISTS signed_in;
CREATE TABLE signed_in (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  PersonID  INTEGER REFERENCES people(PersonID)    ON DELETE SET NULL,
  MeetingID INTEGER REFERENCES meetings(MeetingID) ON DELETE SET NULL,
  InTime TIME NOT NULL,

  UNIQUE (PersonID, MeetingID)
);

CREATE OR REPLACE FUNCTION fn_signed_in_nulldel()
  RETURNS TRIGGER AS
$func$
  BEGIN
    DELETE FROM signed_in WHERE id = NEW.id;
    RETURN NULL;
  END;
$func$ LANGUAGE plpgsql;

CREATE TRIGGER trg_signed_in_nulldel
  BEFORE UPDATE OF PersonID, MeetingID on signed_in
  FOR EACH ROW
  WHEN  (NEW.PersonID IS NULL OR NEW.MeetingID IS NULL)
  EXECUTE PROCEDURE fn_signed_in_nulldel();



DROP TABLE IF EXISTS signed_out;
CREATE TABLE signed_out (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  PersonID  INTEGER REFERENCES people(PersonID)    ON DELETE SET NULL,
  MeetingID INTEGER REFERENCES meetings(MeetingID) ON DELETE SET NULL,
  outTime TIME NOT NULL,

  UNIQUE (PersonID, MeetingID)
);

CREATE OR REPLACE FUNCTION fn_signed_out_nulldel()
  RETURNS TRIGGER AS
$func$
  BEGIN
    DELETE FROM signed_out WHERE id = NEW.id;
    RETURN NULL;
  END;
$func$ LANGUAGE plpgsql;

CREATE TRIGGER trg_signed_out_nulldel
  BEFORE UPDATE OF PersonID, MeetingID on signed_out
  FOR EACH ROW
  WHEN  (NEW.PersonID IS NULL OR NEW.MeetingID IS NULL)
  EXECUTE PROCEDURE fn_signed_out_nulldel();



DROP TABLE IF EXISTS mentors;
CREATE TABLE mentors(
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  PersonID INTEGER REFERENCES people(PersonID) ON DELETE SET NULL,
  TeamID   INTEGER REFERENCES teams(TeamID)    ON DELETE SET NULL,

  UNIQUE (PersonID, TeamID)
);

CREATE OR REPLACE FUNCTION fn_mentors_nulldel()
  RETURNS TRIGGER AS
$func$
  BEGIN
    DELETE FROM mentors WHERE id = NEW.id;
    RETURN NULL;
  END;
$func$ LANGUAGE plpgsql;

CREATE TRIGGER trg_mentors_nulldel
  BEFORE UPDATE OF PersonID, TeamID on mentors
  FOR EACH ROW
  WHEN  (NEW.PersonID IS NULL OR NEW.TeamID IS NULL)
  EXECUTE PROCEDURE fn_mentors_nulldel();



DROP TABLE IF EXISTS students;
CREATE TABLE students (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  PersonID  INTEGER REFERENCES people(PersonID) ON DELETE SET NULL,
  TeamID    INTEGER REFERENCES teams(TeamID)    ON DELETE SET NULL,

  UNIQUE (PersonID, TeamID)
);

CREATE OR REPLACE FUNCTION fn_students_nulldel()
  RETURNS TRIGGER AS
$func$
  BEGIN
    DELETE FROM students WHERE id = NEW.id;
    RETURN NULL;
  END;
$func$ LANGUAGE plpgsql;

CREATE TRIGGER trg_students_nulldel
  BEFORE UPDATE OF PersonID, TeamID on students
  FOR EACH ROW
  WHEN  (NEW.PersonID IS NULL OR NEW.TeamID IS NULL)
  EXECUTE PROCEDURE fn_students_nulldel();



DROP TABLE IF EXISTS parents;
CREATE TABLE parents(
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  ParentID  INTEGER REFERENCES people(PersonID) ON DELETE SET NULL,
  StudentID INTEGER REFERENCES people(PersonID) ON DELETE SET NULL,

  Relation PARENTRELATION NOT NULL,

  UNIQUE (ParentID, StudentID)
);

CREATE OR REPLACE FUNCTION fn_parents_nulldel()
  RETURNS TRIGGER AS
$func$
  BEGIN
    DELETE FROM parents WHERE id = NEW.id;
    RETURN NULL;
  END;
$func$ LANGUAGE plpgsql;

CREATE TRIGGER trg_parents_nulldel
  BEFORE UPDATE OF ParentID, StudentID on parents
  FOR EACH ROW
  WHEN  (NEW.ParentID IS NULL OR NEW.StudentID IS NULL)
  EXECUTE PROCEDURE fn_parents_nulldel();

--